#!/bin/bash

# CI Setup Script for CrackSeg E2E Testing
# This script configures the Docker environment for GitHub Actions CI/CD
# Part of Task 14.10 - Docker and CI Integration

set -euo pipefail

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"
CI_CONFIG_DIR="$SCRIPT_DIR/../ci"

# Logging functions
log_info() {
    echo "ℹ️  [CI-SETUP] $*"
}

log_success() {
    echo "✅ [CI-SETUP] $*"
}

log_warning() {
    echo "⚠️  [CI-SETUP] $*"
}

log_error() {
    echo "❌ [CI-SETUP] $*" >&2
}

# Function to show usage
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Configure Docker environment for GitHub Actions CI/CD

OPTIONS:
    --environment ENV    Target environment (ci, staging, production)
    --validate          Validate CI configuration
    --dry-run           Show what would be done without executing
    --help              Show this help message

EXAMPLES:
    $0 --environment ci
    $0 --validate
    $0 --dry-run --environment staging

EOF
}

# Function to validate environment
validate_environment() {
    local env="$1"

    log_info "Validating environment: $env"

    # Check if environment template exists
    local env_template="$SCRIPT_DIR/../env.${env}.template"
    if [[ ! -f "$env_template" ]]; then
        log_error "Environment template not found: $env_template"
        return 1
    fi

    # Check required directories
    local required_dirs=(
        "$PROJECT_ROOT/.github/workflows"
        "$PROJECT_ROOT/infrastructure/testing"
        "$PROJECT_ROOT/tests/e2e"
    )

    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            log_error "Required directory not found: $dir"
            return 1
        fi
    done

    # Check required files
    local required_files=(
        "$PROJECT_ROOT/.github/workflows/e2e-testing.yml"
        "$PROJECT_ROOT/infrastructure/testing/docker/docker-compose.test.yml"
        "$SCRIPT_DIR/docker-stack-manager.sh"
        "$SCRIPT_DIR/e2e-test-orchestrator.sh"
    )

    for file in "${required_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            log_error "Required file not found: $file"
            return 1
        fi
    done

    log_success "Environment validation passed"
    return 0
}

# Function to setup CI configuration
setup_ci_config() {
    local environment="$1"
    local dry_run="${2:-false}"

    log_info "Setting up CI configuration for environment: $environment"

    # Create CI configuration directory
    if [[ "$dry_run" == "false" ]]; then
        mkdir -p "$CI_CONFIG_DIR"
    else
        log_info "[DRY-RUN] Would create directory: $CI_CONFIG_DIR"
    fi

    # Copy and configure environment file
    local env_template="$SCRIPT_DIR/../env.${environment}.template"
    local env_file="$SCRIPT_DIR/../.env.${environment}"

    if [[ "$dry_run" == "false" ]]; then
        cp "$env_template" "$env_file"

        # Add CI-specific configuration
        cat >> "$env_file" << EOF

# CI-specific configuration (auto-generated)
CI=true
GITHUB_ACTIONS=true
TEST_HEADLESS=true
COVERAGE_ENABLED=true
ARTIFACT_COLLECTION_ENABLED=true
ARTIFACT_CLEANUP_ENABLED=true
BUILD_NUMBER=\${BUILD_NUMBER:-local}
GIT_COMMIT=\${GIT_COMMIT:-unknown}
GIT_BRANCH=\${GIT_BRANCH:-local}
DEPLOYMENT_TIME=\$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Performance optimization for CI
PARALLEL_WORKERS=\${PARALLEL_WORKERS:-2}
TEST_TIMEOUT=\${TEST_TIMEOUT:-600}
STARTUP_TIMEOUT=\${STARTUP_TIMEOUT:-300}

# Resource limits for CI
DOCKER_MEMORY_LIMIT=4g
DOCKER_CPU_LIMIT=2.0
SELENIUM_MEMORY_LIMIT=2g

# Debugging in CI
DEBUG_MODE=\${DEBUG_MODE:-false}
VERBOSE_LOGGING=\${VERBOSE_LOGGING:-true}
KEEP_ARTIFACTS_ON_SUCCESS=\${KEEP_ARTIFACTS_ON_SUCCESS:-false}
EOF

        log_success "Environment file configured: $env_file"
    else
        log_info "[DRY-RUN] Would configure environment file: $env_file"
    fi

    # Create CI-specific override compose file
    local ci_compose="$SCRIPT_DIR/../docker-compose.ci.yml"

    if [[ "$dry_run" == "false" ]]; then
        cat > "$ci_compose" << 'EOF'
# CI-specific Docker Compose overrides
# This file is automatically generated by ci-setup.sh

version: '3.8'

services:
  streamlit:
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'
    environment:
      - STREAMLIT_SERVER_HEADLESS=true
      - STREAMLIT_BROWSER_GATHER_USAGE_STATS=false
      - STREAMLIT_SERVER_ENABLE_CORS=false
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8501/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  selenium-chrome:
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'
    environment:
      - SE_OPTS=--session-request-timeout 300 --session-retry-interval 5
    shm_size: 2gb

  selenium-firefox:
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'
    environment:
      - SE_OPTS=--session-request-timeout 300 --session-retry-interval 5
    shm_size: 2gb

  test-runner:
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M
          cpus: '0.25'
    environment:
      - PYTEST_WORKERS=${PARALLEL_WORKERS:-2}
      - PYTEST_TIMEOUT=${TEST_TIMEOUT:-600}
      - COVERAGE_ENABLED=${COVERAGE_ENABLED:-true}

networks:
  crackseg-test-network:
    driver: bridge
    driver_opts:
      com.docker.network.driver.mtu: 1450

volumes:
  test-results:
  test-artifacts:
  selenium-videos:
EOF

        log_success "CI compose override created: $ci_compose"
    else
        log_info "[DRY-RUN] Would create CI compose override: $ci_compose"
    fi

    # Create GitHub Actions helper script
    local gh_helper="$CI_CONFIG_DIR/github-actions-helper.sh"

    if [[ "$dry_run" == "false" ]]; then
        cat > "$gh_helper" << 'EOF'
#!/bin/bash

# GitHub Actions Helper Script
# Provides utility functions for GitHub Actions workflows

set -euo pipefail

# Function to setup GitHub Actions environment
setup_github_actions_env() {
    local browser="${1:-chrome}"
    local test_suite="${2:-smoke}"

    echo "🔧 Setting up GitHub Actions environment"

    # Export environment variables for GitHub Actions
    {
        echo "BROWSER=$browser"
        echo "TEST_SUITE=$test_suite"
        echo "CI=true"
        echo "GITHUB_ACTIONS=true"
        echo "TEST_HEADLESS=true"
        echo "COVERAGE_ENABLED=true"
        echo "BUILD_NUMBER=${GITHUB_RUN_NUMBER:-local}"
        echo "GIT_COMMIT=${GITHUB_SHA:-unknown}"
        echo "GIT_BRANCH=${GITHUB_REF_NAME:-local}"
    } >> "$GITHUB_ENV"

    # Create artifact directories
    mkdir -p test-results test-artifacts selenium-videos archived-artifacts

    echo "✅ GitHub Actions environment configured"
}

# Function to collect CI artifacts
collect_ci_artifacts() {
    local browser="$1"
    local test_suite="$2"

    echo "📦 Collecting CI artifacts for $browser ($test_suite)"

    # Create timestamp
    local timestamp=$(date +"%Y%m%d_%H%M%S")

    # Collect test results
    if [[ -d "test-results" ]]; then
        echo "Collecting test results..."
        tar -czf "test-results-${browser}-${test_suite}-${timestamp}.tar.gz" test-results/
    fi

    # Collect test artifacts
    if [[ -d "test-artifacts" ]]; then
        echo "Collecting test artifacts..."
        tar -czf "test-artifacts-${browser}-${test_suite}-${timestamp}.tar.gz" test-artifacts/
    fi

    # Collect videos on failure
    if [[ -d "selenium-videos" ]] && [[ "$(ls -A selenium-videos 2>/dev/null)" ]]; then
        echo "Collecting video recordings..."
        tar -czf "video-recordings-${browser}-${test_suite}-${timestamp}.tar.gz" selenium-videos/
    fi

    echo "✅ Artifact collection completed"
}

# Function to validate GitHub Actions setup
validate_github_actions_setup() {
    echo "🔍 Validating GitHub Actions setup"

    local required_vars=(
        "GITHUB_ACTIONS"
        "GITHUB_WORKSPACE"
        "GITHUB_REPOSITORY"
        "GITHUB_SHA"
    )

    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            echo "❌ Required GitHub Actions variable not set: $var"
            return 1
        fi
    done

    # Check if running in GitHub Actions
    if [[ "${GITHUB_ACTIONS:-false}" != "true" ]]; then
        echo "⚠️  Not running in GitHub Actions environment"
        return 1
    fi

    echo "✅ GitHub Actions setup validation passed"
    return 0
}

# Main function
main() {
    local action="${1:-setup}"
    shift || true

    case "$action" in
        "setup")
            setup_github_actions_env "$@"
            ;;
        "collect")
            collect_ci_artifacts "$@"
            ;;
        "validate")
            validate_github_actions_setup
            ;;
        *)
            echo "Usage: $0 {setup|collect|validate} [args...]"
            exit 1
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
EOF

        chmod +x "$gh_helper"
        log_success "GitHub Actions helper created: $gh_helper"
    else
        log_info "[DRY-RUN] Would create GitHub Actions helper: $gh_helper"
    fi
}

# Function to validate CI configuration
validate_ci_config() {
    log_info "Validating CI configuration"

    # Check Docker compose syntax
    if ! docker-compose -f "$SCRIPT_DIR/../docker/docker-compose.test.yml" config > /dev/null 2>&1; then
        log_error "Docker compose configuration invalid"
        return 1
    fi

    # Check if CI override exists and is valid
    local ci_compose="$SCRIPT_DIR/../docker-compose.ci.yml"
    if [[ -f "$ci_compose" ]]; then
        if ! docker-compose -f "$SCRIPT_DIR/../docker/docker-compose.test.yml" -f "$ci_compose" config > /dev/null 2>&1; then
            log_error "CI compose override configuration invalid"
            return 1
        fi
    fi

    # Check GitHub Actions workflows
    local workflows=(
        "$PROJECT_ROOT/.github/workflows/e2e-testing.yml"
        "$PROJECT_ROOT/.github/workflows/deploy-production.yml"
        "$PROJECT_ROOT/.github/workflows/test-reporting.yml"
    )

    for workflow in "${workflows[@]}"; do
        if [[ -f "$workflow" ]]; then
            log_info "Found workflow: $(basename "$workflow")"
        else
            log_warning "Workflow not found: $(basename "$workflow")"
        fi
    done

    # Check required scripts
    local scripts=(
        "$SCRIPT_DIR/docker-stack-manager.sh"
        "$SCRIPT_DIR/e2e-test-orchestrator.sh"
        "$SCRIPT_DIR/artifact-manager.sh"
        "$SCRIPT_DIR/system-monitor.sh"
    )

    for script in "${scripts[@]}"; do
        if [[ -f "$script" ]] && [[ -x "$script" ]]; then
            log_success "Script found and executable: $(basename "$script")"
        else
            log_error "Script missing or not executable: $(basename "$script")"
            return 1
        fi
    done

    log_success "CI configuration validation completed"
    return 0
}

# Main function
main() {
    local environment="ci"
    local validate_only=false
    local dry_run=false

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --environment)
                environment="$2"
                shift 2
                ;;
            --validate)
                validate_only=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Validate environment first
    if ! validate_environment "$environment"; then
        log_error "Environment validation failed"
        exit 1
    fi

    # If validation only, exit here
    if [[ "$validate_only" == "true" ]]; then
        validate_ci_config
        exit $?
    fi

    # Setup CI configuration
    setup_ci_config "$environment" "$dry_run"

    # Validate the setup unless it's a dry run
    if [[ "$dry_run" == "false" ]]; then
        validate_ci_config
    fi

    log_success "CI setup completed successfully for environment: $environment"

    # Show next steps
    cat << EOF

🎉 CI Setup Complete!

Next steps:
1. Commit the generated CI configuration files
2. Push to GitHub to trigger the CI/CD pipeline
3. Monitor the GitHub Actions workflows

Generated files:
- CI environment file: $SCRIPT_DIR/../.env.$environment
- CI compose override: $SCRIPT_DIR/../docker-compose.ci.yml
- GitHub Actions helper: $CI_CONFIG_DIR/github-actions-helper.sh

To test the setup locally:
  cd tests/docker
  ./scripts/docker-stack-manager.sh start --ci-mode
  ./scripts/e2e-test-orchestrator.sh smoke --ci-mode

To validate the setup:
  $0 --validate

EOF
}

# Execute main function
main "$@"